#include <array>
#include <cstdint>
#include <span>
#include <tuple>

#include <vulkan/vulkan_core.h>

#include "printTable.hpp"
#include "vulkanDevice.hpp"

namespace vul {
// clang-format off
const std::array<VulkanDevice::PropertiesT, 172> VulkanDevice::deviceProperty{ // NOLINT
    std::make_tuple("deviceID", [](const DeviceData& data) { return printTable::number(data.properties.deviceID); }),
    std::make_tuple("vendorID", [](const DeviceData& data) { return printTable::vendor(data.properties.vendorID); }),
    std::make_tuple("deviceType", [](const DeviceData& data) { return deviceType(data.properties.deviceType); }),
    std::make_tuple("apiVersion", [](const DeviceData& data) { return printTable::version(data.properties.apiVersion); }),
    std::make_tuple("driverVersion", [](const DeviceData& data) { return printTable::version(data.properties.driverVersion); }),
    std::make_tuple("pipelineCacheUUID", [](const DeviceData& data) { return printTable::table(std::span(static_cast<const uint8_t*>(data.properties.pipelineCacheUUID), VK_UUID_SIZE)); }),

    std::make_tuple("maxImageDimension1D", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxImageDimension1D); }),
    std::make_tuple("maxImageDimension2D", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxImageDimension2D); }),
    std::make_tuple("maxImageDimension3D", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxImageDimension3D); }),
    std::make_tuple("maxImageDimensionCube", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxImageDimensionCube); }),
    std::make_tuple("maxImageArrayLayers", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxImageArrayLayers); }),
    std::make_tuple("maxTexelBufferElements", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxTexelBufferElements); }),
    std::make_tuple("maxUniformBufferRange", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxUniformBufferRange); }),
    std::make_tuple("maxStorageBufferRange", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxStorageBufferRange); }),
    std::make_tuple("maxPushConstantsSize", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxPushConstantsSize); }),
    std::make_tuple("maxMemoryAllocationCount", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxMemoryAllocationCount); }),
    std::make_tuple("maxSamplerAllocationCount", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxSamplerAllocationCount); }),
    std::make_tuple("bufferImageGranularity", [](const DeviceData& data) { return printTable::number(data.properties.limits.bufferImageGranularity); }),
    std::make_tuple("sparseAddressSpaceSize", [](const DeviceData& data) { return printTable::number(data.properties.limits.sparseAddressSpaceSize); }),
    std::make_tuple("maxBoundDescriptorSets", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxBoundDescriptorSets); }),
    std::make_tuple("maxPerStageDescriptorSamplers", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxPerStageDescriptorSamplers); }),
    std::make_tuple("maxPerStageDescriptorUniformBuffers", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxPerStageDescriptorUniformBuffers); }),
    std::make_tuple("maxPerStageDescriptorStorageBuffers", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxPerStageDescriptorStorageBuffers); }),
    std::make_tuple("maxPerStageDescriptorSampledImages", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxPerStageDescriptorSampledImages); }),
    std::make_tuple("maxPerStageDescriptorStorageImages", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxPerStageDescriptorStorageImages); }),
    std::make_tuple("maxPerStageDescriptorInputAttachments", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxPerStageDescriptorInputAttachments); }),
    std::make_tuple("maxPerStageResources", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxPerStageResources); }),
    std::make_tuple("maxDescriptorSetSamplers", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxDescriptorSetSamplers); }),
    std::make_tuple("maxDescriptorSetUniformBuffers", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxDescriptorSetUniformBuffers); }),
    std::make_tuple("maxDescriptorSetUniformBuffersDynamic", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxDescriptorSetUniformBuffersDynamic); }),
    std::make_tuple("maxDescriptorSetStorageBuffers", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxDescriptorSetStorageBuffers); }),
    std::make_tuple("maxDescriptorSetStorageBuffersDynamic", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxDescriptorSetStorageBuffersDynamic); }),
    std::make_tuple("maxDescriptorSetSampledImages", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxDescriptorSetSampledImages); }),
    std::make_tuple("maxDescriptorSetStorageImages", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxDescriptorSetStorageImages); }),
    std::make_tuple("maxDescriptorSetInputAttachments", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxDescriptorSetInputAttachments); }),
    std::make_tuple("maxVertexInputAttributes", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxVertexInputAttributes); }),
    std::make_tuple("maxVertexInputBindings", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxVertexInputBindings); }),
    std::make_tuple("maxVertexInputAttributeOffset", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxVertexInputAttributeOffset); }),
    std::make_tuple("maxVertexInputBindingStride", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxVertexInputBindingStride); }),
    std::make_tuple("maxVertexOutputComponents", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxVertexOutputComponents); }),
    std::make_tuple("maxTessellationGenerationLevel", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxTessellationGenerationLevel); }),
    std::make_tuple("maxTessellationPatchSize", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxTessellationPatchSize); }),
    std::make_tuple("maxTessellationControlPerVertexInputComponents", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxTessellationControlPerVertexInputComponents); }),
    std::make_tuple("maxTessellationControlPerVertexOutputComponents", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxTessellationControlPerVertexOutputComponents); }),
    std::make_tuple("maxTessellationControlPerPatchOutputComponents", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxTessellationControlPerPatchOutputComponents); }),
    std::make_tuple("maxTessellationControlTotalOutputComponents", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxTessellationControlTotalOutputComponents); }),
    std::make_tuple("maxTessellationEvaluationInputComponents", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxTessellationEvaluationInputComponents); }),
    std::make_tuple("maxTessellationEvaluationOutputComponents", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxTessellationEvaluationOutputComponents); }),
    std::make_tuple("maxGeometryShaderInvocations", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxGeometryShaderInvocations); }),
    std::make_tuple("maxGeometryInputComponents", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxGeometryInputComponents); }),
    std::make_tuple("maxGeometryOutputComponents", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxGeometryOutputComponents); }),
    std::make_tuple("maxGeometryOutputVertices", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxGeometryOutputVertices); }),
    std::make_tuple("maxGeometryTotalOutputComponents", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxGeometryTotalOutputComponents); }),
    std::make_tuple("maxFragmentInputComponents", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxFragmentInputComponents); }),
    std::make_tuple("maxFragmentOutputAttachments", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxFragmentOutputAttachments); }),
    std::make_tuple("maxFragmentDualSrcAttachments", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxFragmentDualSrcAttachments); }),
    std::make_tuple("maxFragmentCombinedOutputResources", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxFragmentCombinedOutputResources); }),
    std::make_tuple("maxComputeSharedMemorySize", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxComputeSharedMemorySize); }),
    std::make_tuple("maxComputeWorkGroupCount", [](const DeviceData& data) { return printTable::table(std::span(static_cast<const uint32_t*>(data.properties.limits.maxComputeWorkGroupCount), 3)); }),
    std::make_tuple("maxComputeWorkGroupInvocations", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxComputeWorkGroupInvocations); }),
    std::make_tuple("maxComputeWorkGroupSize", [](const DeviceData& data) { return printTable::table(std::span(static_cast<const uint32_t*>(data.properties.limits.maxComputeWorkGroupSize), 3)); }),
    std::make_tuple("subPixelPrecisionBits", [](const DeviceData& data) { return printTable::number(data.properties.limits.subPixelPrecisionBits); }),
    std::make_tuple("subTexelPrecisionBits", [](const DeviceData& data) { return printTable::number(data.properties.limits.subTexelPrecisionBits); }),
    std::make_tuple("mipmapPrecisionBits", [](const DeviceData& data) { return printTable::number(data.properties.limits.mipmapPrecisionBits); }),
    std::make_tuple("maxDrawIndexedIndexValue", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxDrawIndexedIndexValue); }),
    std::make_tuple("maxDrawIndirectCount", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxDrawIndirectCount); }),
    std::make_tuple("maxSamplerLodBias", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxSamplerLodBias); }),
    std::make_tuple("maxSamplerAnisotropy", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxSamplerAnisotropy); }),
    std::make_tuple("maxViewports", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxViewports); }),
    std::make_tuple("maxViewportDimensions", [](const DeviceData& data) { return printTable::table(std::span(static_cast<const uint32_t*>(data.properties.limits.maxViewportDimensions), 2)); }),
    std::make_tuple("viewportBoundsRange", [](const DeviceData& data) { return printTable::table(std::span(static_cast<const float*>(data.properties.limits.viewportBoundsRange), 2)); }),
    std::make_tuple("viewportSubPixelBits", [](const DeviceData& data) { return printTable::number(data.properties.limits.viewportSubPixelBits); }),
    std::make_tuple("minMemoryMapAlignment", [](const DeviceData& data) { return printTable::number(data.properties.limits.minMemoryMapAlignment); }),
    std::make_tuple("minTexelBufferOffsetAlignment", [](const DeviceData& data) { return printTable::number(data.properties.limits.minTexelBufferOffsetAlignment); }),
    std::make_tuple("minUniformBufferOffsetAlignment", [](const DeviceData& data) { return printTable::number(data.properties.limits.minUniformBufferOffsetAlignment); }),
    std::make_tuple("minStorageBufferOffsetAlignment", [](const DeviceData& data) { return printTable::number(data.properties.limits.minStorageBufferOffsetAlignment); }),
    std::make_tuple("minTexelOffset", [](const DeviceData& data) { return printTable::number(data.properties.limits.minTexelOffset); }),
    std::make_tuple("maxTexelOffset", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxTexelOffset); }),
    std::make_tuple("minTexelGatherOffset", [](const DeviceData& data) { return printTable::number(data.properties.limits.minTexelGatherOffset); }),
    std::make_tuple("maxTexelGatherOffset", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxTexelGatherOffset); }),
    std::make_tuple("minInterpolationOffset", [](const DeviceData& data) { return printTable::number(data.properties.limits.minInterpolationOffset); }),
    std::make_tuple("maxInterpolationOffset", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxInterpolationOffset); }),
    std::make_tuple("subPixelInterpolationOffsetBits", [](const DeviceData& data) { return printTable::number(data.properties.limits.subPixelInterpolationOffsetBits); }),
    std::make_tuple("maxFramebufferWidth", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxFramebufferWidth); }),
    std::make_tuple("maxFramebufferHeight", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxFramebufferHeight); }),
    std::make_tuple("maxFramebufferLayers", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxFramebufferLayers); }),
    std::make_tuple("framebufferColorSampleCounts", [](const DeviceData& data) { return printTable::number(data.properties.limits.framebufferColorSampleCounts); }),
    std::make_tuple("framebufferDepthSampleCounts", [](const DeviceData& data) { return printTable::number(data.properties.limits.framebufferDepthSampleCounts); }),
    std::make_tuple("framebufferStencilSampleCounts", [](const DeviceData& data) { return printTable::number(data.properties.limits.framebufferStencilSampleCounts); }),
    std::make_tuple("framebufferNoAttachmentsSampleCounts", [](const DeviceData& data) { return printTable::number(data.properties.limits.framebufferNoAttachmentsSampleCounts); }),
    std::make_tuple("maxColorAttachments", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxColorAttachments); }),
    std::make_tuple("sampledImageColorSampleCounts", [](const DeviceData& data) { return printTable::number(data.properties.limits.sampledImageColorSampleCounts); }),
    std::make_tuple("sampledImageIntegerSampleCounts", [](const DeviceData& data) { return printTable::number(data.properties.limits.sampledImageIntegerSampleCounts); }),
    std::make_tuple("sampledImageDepthSampleCounts", [](const DeviceData& data) { return printTable::number(data.properties.limits.sampledImageDepthSampleCounts); }),
    std::make_tuple("sampledImageStencilSampleCounts", [](const DeviceData& data) { return printTable::number(data.properties.limits.sampledImageStencilSampleCounts); }),
    std::make_tuple("storageImageSampleCounts", [](const DeviceData& data) { return printTable::number(data.properties.limits.storageImageSampleCounts); }),
    std::make_tuple("maxSampleMaskWords", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxSampleMaskWords); }),
    std::make_tuple("timestampComputeAndGraphics", [](const DeviceData& data) { return printTable::boolean(data.properties.limits.timestampComputeAndGraphics); }),
    std::make_tuple("timestampPeriod", [](const DeviceData& data) { return printTable::number(data.properties.limits.timestampPeriod); }),
    std::make_tuple("maxClipDistances", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxClipDistances); }),
    std::make_tuple("maxCullDistances", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxCullDistances); }),
    std::make_tuple("maxCombinedClipAndCullDistances", [](const DeviceData& data) { return printTable::number(data.properties.limits.maxCombinedClipAndCullDistances); }),
    std::make_tuple("discreteQueuePriorities", [](const DeviceData& data) { return printTable::number(data.properties.limits.discreteQueuePriorities); }),
    std::make_tuple("pointSizeRange", [](const DeviceData& data) { return printTable::table(std::span(static_cast<const float*>(data.properties.limits.pointSizeRange), 2)); }),
    std::make_tuple("lineWidthRange", [](const DeviceData& data) { return printTable::table(std::span(static_cast<const float*>(data.properties.limits.lineWidthRange), 2)); }),
    std::make_tuple("pointSizeGranularity", [](const DeviceData& data) { return printTable::number(data.properties.limits.pointSizeGranularity); }),
    std::make_tuple("lineWidthGranularity", [](const DeviceData& data) { return printTable::number(data.properties.limits.lineWidthGranularity); }),
    std::make_tuple("strictLines", [](const DeviceData& data) { return printTable::boolean(data.properties.limits.strictLines); }),
    std::make_tuple("standardSampleLocations", [](const DeviceData& data) { return printTable::boolean(data.properties.limits.standardSampleLocations); }),
    std::make_tuple("optimalBufferCopyOffsetAlignment", [](const DeviceData& data) { return printTable::number(data.properties.limits.optimalBufferCopyOffsetAlignment); }),
    std::make_tuple("optimalBufferCopyRowPitchAlignment", [](const DeviceData& data) { return printTable::number(data.properties.limits.optimalBufferCopyRowPitchAlignment); }),
    std::make_tuple("nonCoherentAtomSize", [](const DeviceData& data) { return printTable::number(data.properties.limits.nonCoherentAtomSize); }),

    std::make_tuple("residencyStandard2DBlockShape", [](const DeviceData& data) { return printTable::boolean(data.properties.sparseProperties.residencyStandard2DBlockShape); }),
    std::make_tuple("residencyStandard2DMultisampleBlockShape", [](const DeviceData& data) { return printTable::boolean(data.properties.sparseProperties.residencyStandard2DMultisampleBlockShape); }),
    std::make_tuple("residencyStandard3DBlockShape", [](const DeviceData& data) { return printTable::boolean(data.properties.sparseProperties.residencyStandard3DBlockShape); }),
    std::make_tuple("residencyAlignedMipSize", [](const DeviceData& data) { return printTable::boolean(data.properties.sparseProperties.residencyAlignedMipSize); }),
    std::make_tuple("residencyNonResidentStrict", [](const DeviceData& data) { return printTable::boolean(data.properties.sparseProperties.residencyNonResidentStrict); }),

    std::make_tuple("robustBufferAccess", [](const DeviceData& data) { return printTable::boolean(data.features.robustBufferAccess); }),
    std::make_tuple("fullDrawIndexUint32", [](const DeviceData& data) { return printTable::boolean(data.features.fullDrawIndexUint32); }),
    std::make_tuple("imageCubeArray", [](const DeviceData& data) { return printTable::boolean(data.features.imageCubeArray); }),
    std::make_tuple("independentBlend", [](const DeviceData& data) { return printTable::boolean(data.features.independentBlend); }),
    std::make_tuple("geometryShader", [](const DeviceData& data) { return printTable::boolean(data.features.geometryShader); }),
    std::make_tuple("tessellationShader", [](const DeviceData& data) { return printTable::boolean(data.features.tessellationShader); }),
    std::make_tuple("sampleRateShading", [](const DeviceData& data) { return printTable::boolean(data.features.sampleRateShading); }),
    std::make_tuple("dualSrcBlend", [](const DeviceData& data) { return printTable::boolean(data.features.dualSrcBlend); }),
    std::make_tuple("logicOp", [](const DeviceData& data) { return printTable::boolean(data.features.logicOp); }),
    std::make_tuple("multiDrawIndirect", [](const DeviceData& data) { return printTable::boolean(data.features.multiDrawIndirect); }),
    std::make_tuple("drawIndirectFirstInstance", [](const DeviceData& data) { return printTable::boolean(data.features.drawIndirectFirstInstance); }),
    std::make_tuple("depthClamp", [](const DeviceData& data) { return printTable::boolean(data.features.depthClamp); }),
    std::make_tuple("depthBiasClamp", [](const DeviceData& data) { return printTable::boolean(data.features.depthBiasClamp); }),
    std::make_tuple("fillModeNonSolid", [](const DeviceData& data) { return printTable::boolean(data.features.fillModeNonSolid); }),
    std::make_tuple("depthBounds", [](const DeviceData& data) { return printTable::boolean(data.features.depthBounds); }),
    std::make_tuple("wideLines", [](const DeviceData& data) { return printTable::boolean(data.features.wideLines); }),
    std::make_tuple("largePoints", [](const DeviceData& data) { return printTable::boolean(data.features.largePoints); }),
    std::make_tuple("alphaToOne", [](const DeviceData& data) { return printTable::boolean(data.features.alphaToOne); }),
    std::make_tuple("multiViewport", [](const DeviceData& data) { return printTable::boolean(data.features.multiViewport); }),
    std::make_tuple("samplerAnisotropy", [](const DeviceData& data) { return printTable::boolean(data.features.samplerAnisotropy); }),
    std::make_tuple("textureCompressionETC2", [](const DeviceData& data) { return printTable::boolean(data.features.textureCompressionETC2); }),
    std::make_tuple("textureCompressionASTC_LDR", [](const DeviceData& data) { return printTable::boolean(data.features.textureCompressionASTC_LDR); }),
    std::make_tuple("textureCompressionBC", [](const DeviceData& data) { return printTable::boolean(data.features.textureCompressionBC); }),
    std::make_tuple("occlusionQueryPrecise", [](const DeviceData& data) { return printTable::boolean(data.features.occlusionQueryPrecise); }),
    std::make_tuple("pipelineStatisticsQuery", [](const DeviceData& data) { return printTable::boolean(data.features.pipelineStatisticsQuery); }),
    std::make_tuple("vertexPipelineStoresAndAtomics", [](const DeviceData& data) { return printTable::boolean(data.features.vertexPipelineStoresAndAtomics); }),
    std::make_tuple("fragmentStoresAndAtomics", [](const DeviceData& data) { return printTable::boolean(data.features.fragmentStoresAndAtomics); }),
    std::make_tuple("shaderTessellationAndGeometryPointSize", [](const DeviceData& data) { return printTable::boolean(data.features.shaderTessellationAndGeometryPointSize); }),
    std::make_tuple("shaderImageGatherExtended", [](const DeviceData& data) { return printTable::boolean(data.features.shaderImageGatherExtended); }),
    std::make_tuple("shaderStorageImageExtendedFormats", [](const DeviceData& data) { return printTable::boolean(data.features.shaderStorageImageExtendedFormats); }),
    std::make_tuple("shaderStorageImageMultisample", [](const DeviceData& data) { return printTable::boolean(data.features.shaderStorageImageMultisample); }),
    std::make_tuple("shaderStorageImageReadWithoutFormat", [](const DeviceData& data) { return printTable::boolean(data.features.shaderStorageImageReadWithoutFormat); }),
    std::make_tuple("shaderStorageImageWriteWithoutFormat", [](const DeviceData& data) { return printTable::boolean(data.features.shaderStorageImageWriteWithoutFormat); }),
    std::make_tuple("shaderUniformBufferArrayDynamicIndexing", [](const DeviceData& data) { return printTable::boolean(data.features.shaderUniformBufferArrayDynamicIndexing); }),
    std::make_tuple("shaderSampledImageArrayDynamicIndexing", [](const DeviceData& data) { return printTable::boolean(data.features.shaderSampledImageArrayDynamicIndexing); }),
    std::make_tuple("shaderStorageBufferArrayDynamicIndexing", [](const DeviceData& data) { return printTable::boolean(data.features.shaderStorageBufferArrayDynamicIndexing); }),
    std::make_tuple("shaderStorageImageArrayDynamicIndexing", [](const DeviceData& data) { return printTable::boolean(data.features.shaderStorageImageArrayDynamicIndexing); }),
    std::make_tuple("shaderClipDistance", [](const DeviceData& data) { return printTable::boolean(data.features.shaderClipDistance); }),
    std::make_tuple("shaderCullDistance", [](const DeviceData& data) { return printTable::boolean(data.features.shaderCullDistance); }),
    std::make_tuple("shaderFloat64", [](const DeviceData& data) { return printTable::boolean(data.features.shaderFloat64); }),
    std::make_tuple("shaderInt64", [](const DeviceData& data) { return printTable::boolean(data.features.shaderInt64); }),
    std::make_tuple("shaderInt16", [](const DeviceData& data) { return printTable::boolean(data.features.shaderInt16); }),
    std::make_tuple("shaderResourceResidency", [](const DeviceData& data) { return printTable::boolean(data.features.shaderResourceResidency); }),
    std::make_tuple("shaderResourceMinLod", [](const DeviceData& data) { return printTable::boolean(data.features.shaderResourceMinLod); }),
    std::make_tuple("sparseBinding", [](const DeviceData& data) { return printTable::boolean(data.features.sparseBinding); }),
    std::make_tuple("sparseResidencyBuffer", [](const DeviceData& data) { return printTable::boolean(data.features.sparseResidencyBuffer); }),
    std::make_tuple("sparseResidencyImage2D", [](const DeviceData& data) { return printTable::boolean(data.features.sparseResidencyImage2D); }),
    std::make_tuple("sparseResidencyImage3D", [](const DeviceData& data) { return printTable::boolean(data.features.sparseResidencyImage3D); }),
    std::make_tuple("sparseResidency2Samples", [](const DeviceData& data) { return printTable::boolean(data.features.sparseResidency2Samples); }),
    std::make_tuple("sparseResidency4Samples", [](const DeviceData& data) { return printTable::boolean(data.features.sparseResidency4Samples); }),
    std::make_tuple("sparseResidency8Samples", [](const DeviceData& data) { return printTable::boolean(data.features.sparseResidency8Samples); }),
    std::make_tuple("sparseResidency16Samples", [](const DeviceData& data) { return printTable::boolean(data.features.sparseResidency16Samples); }),
    std::make_tuple("sparseResidencyAliased", [](const DeviceData& data) { return printTable::boolean(data.features.sparseResidencyAliased); }),
    std::make_tuple("variableMultisampleRate", [](const DeviceData& data) { return printTable::boolean(data.features.variableMultisampleRate); }),
    std::make_tuple("inheritedQueries", [](const DeviceData& data) { return printTable::boolean(data.features.inheritedQueries); })};
// clang-format on
}  // namespace vul